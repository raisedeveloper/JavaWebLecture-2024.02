*어제 배운 내용
인터페이스의 코드로만 작성하기
리스트-리스트 = 뉴 어레이 리스트(리스트로 구현한 객체가 어레이 리스트)
Set set new hashtag?
Set set new hashmap?

자바는 최소한 편의점 수준의 언어

인터페이스를 구현하기 위해 구현객체를 바로 만들어서 DAO 역할을 할 수 있지만
DAO를 만들어서 구현객체가 Oracle 다오에게 정보를 주는 형태

DAO를 만들고
구현객체하고 DAO랑 연계를 맺어줌
결과 받아서 던져주는 일
만약 혹시라도 DB에 특화된 특성이 있으면 그것을 조금 살려주면 됨
여러개의 DB를 쓸 수 있는 아주 효율적인 방법
interface 만들어놨던 것하고 DAO와 연계하는 구현객체만 만들었음(어제)

application은 인터페이스에 있는 정의된 메소드를 사용 (MessageService 인터페이스 단)


MessageDAO 단: 2024-02-07 09:24:30 이럴 때
DB 조회 결과 : LocalDateTime.parse(구현객체로 만들고 싶을 때 사용하는 메소드)("2024-02-07T09:24:30"); 
		중간에 T를 가져다 붙이기 79번째 줄 (Teacher GitHub) 
Message m = new Message(rs.getInt(1), rs.getString(2), 
		rs.getString(3), LocalDateTime.parse(rs.getString(4).replace(" ", "T"), 0);

MessageSeriveMySQLImpl 단
구현한 클래스 안에서는 어디서든지 쓸 수 있는 msgDao 
mid 변수를 받아서 mid에 변수를 DAO에게 주고 결과를 받아서 결과를 데이터 저장소로, 
Application에 전달

getMessageListAll 몽땅 다 가져오는 것
getMessageListByWriter 작성자가 쓴 글만 가져오는 것
파라메터 없이 들어오는 것도 내가 파라메터 만들어서 데이터를 전달할 수도 있음

insert update delete는 받아서 정보를 던져주면 더 이상 할 것이 없음

형식만 맞춰주는 코드만 입력해주면 저렇게 하라고 만들어져 있음
그것이 스프링 부트가 하는 일

저 방식이 스프링부트에서 구현할 방식이기 때문에 먼저 알고잇는 것이 도움됨
형식맞춰주는 코드 자꾸 보기

MessageTest를 DAO를 테스트하는 단
MessageMain은 어플리케이션
구현객체를 이렇게 만듬

구현객체는 메세지 다오에 종속적이다
디펜던트하다
메세지 다오가 바뀌면 구현객체도 바뀌어야함
그런데 나중에는 종속이라고 하는 의존성을 나중에는 스프링이 자동으로 인셉션해줌

private Message Dao msg Dao = new MessageDao();
나중에는 이 코드가 이러헥 변함 == @Autowired private Message msgDao;
객체를 생성하지 않았지만 그런데 이렇게만 써 놓아도 구현객체가 msgDao를 쓸 수 있게됨
스프링이 구현객체를 만들어서 넣어줌
디펜던시 000 의존성 주입???

현상 발생 : MessageService messageService = new MessageServiceMySQLImpl(); 
앞으로 바뀔 코드 == 앞으로는 메인에서 웹 작업할 일 없음
@Autowired private MessageService messageService;
뒤에 무엇이 오든 코드가 바뀔 일이 없음
내 application은 무엇이 되던지 DB가 무엇이 되든간에 코드를 고칠 일이 없음
모든 DB에 같은 코드를 사용할 수 있게됨
인터페이스에서 알려준 코드를 썼음
MessageMain은 바꿀 필요가 없게됨
데이터를 인터넷으로부터 받는 것만 달라짐 _ 어플리케이션이 대단한 것이 아님
DB를 쓸 것인데 CRUD를 어떻게 사용자화면으로 바꿔 줄 것인가가 중요함


암호화(Crypt) 
1. 복원 가능한 암호화 
-평문을 비문으로 바꿀 수 있음
비문을 평문으로 바꿀 수 있음
위와 같은 것이 복원 가능한 알고리즘임
- 공개키 알고리즘이라고 부름 (복원이 가능하려면 키를 두개를 가져야함)
1. 개인키
2. 공개키
암호화를 할 때 개인키와 공개키를 가지고 작업을 함

2. 비복원 암호화
- 한쪽으로는 가능하나 비문을 평문으로 바꿀 수 없음
위와 같은 것을 비복원 암호화라고 함
대표적인 것이 로그인 작업임
로그인 가능한 패스워드를 입력할 때(암호화할 때) 암호를 설정한 것은 절대로 알 수 없음


평문 		-> 	비문

plain text		cyper text ? cipher text?



-60
$2a$10$Q1fxc6wTqDLL1s4YSLEfwOvgTXmvTnjYniZohteGi.rybAI.aM2FW
암호화된 코드는 char(60)

Correct id
Imbelled Uid 
Incorrect Psw
세 가지의 경우가 있다
== 코드로 나타내면 이하와 같음 
	public static final int correct_login = 0;
	public static final int WRONG_PASSWORD = 1;
	public static final int USER_NOT_EXIST= 2;


1000건 가정 3번쨰 페이지 라면
내가 보아야 할 글자의 갯수는 10개 count per page
offset =2 
page = 3
page-1
int offset = page-1 * count per page작성

이크립스 코드 작성단에서
비지니스 로직이 들어간 것만 내가 바꿔주면 됨
정보를 다오에게 넘겨주고 다오는 메인으로 넘겨줌

메세지 메인에서 만들어야 할 것
1. 페이지 별 목록
- 페이지를 어떻게 만드는가에 따라 보여짐
2. 사용자 등록
3. 사용자 수정
4. 사용자 삭제
5. 로그인
6. 종료

이와 같은 application 을 만들어서 할 수 있음 => 개인적으로 공부할 사람은 만들어 보기

이와 같은 화면이 추후에 웹 화면 구현이 됨

추후에 웹 화면으로 갈 시 클라이언트와 브라우저 그리고 서버가 연동해서 돌아가야 함
현재는 서버 코드만 함
추후에 클라이언트(브라우저) 코드만 만들어 주면 되서 지금까지 작업을 함
server routing, jsp 함께하면 어려워져서 미리 해본 것
웹 서버에서 그대로 쓰는 코드가 됨

오후 1:54 책의 page 3장 관계형 데이터 모델
데이터 타입 - 데이터 구조
연산 - 개념적 데이터 구조 안의 데이터 처리 방식 표현
제약 조건(constraint) 
- 도시 인구 5만~2천만까지 정함. 도시 등록 시 인구수가 5만보다 작거나 2천만을 초과하면 등록되지 않음
- 게시판 글을 쓸 때 로그인 해야만 쓸 수 있음 보드 테이블에 등록 시 누가 기록했는지  
uid 값이 여기 들어감 user 테이블에 없는 uid가 들어가면 안되도록 제약 조건을 걸어줌
보드 테이블에서 유저 테이블의 foreign키로 설정을 해버리면 uid 등록되어 있지 않는 아이디는 보드에 등록이 안되도록 함


릴레이션 : 테이블 형태의 릴레이션을 통해 데이터 저장, 데이터 간의 관련성 표현
제약 사항을 무결정 제약 조건으로 명세
1970년대 말에 나온 모델
관계 대수 사용
데이터를 저장하는 기본 데이터 구조는 릴레이션

atomic value
attribute == 학번 이름 학년 성별, tuple 
김연아 == entity 
성별속성의 domain == 남자 아니면 여자

각 속성의 도메인이 일치할 때만 비교하는 의미가 있음

cardinality & 차수(tuple) 차수는 중복되면 잘못된 릴레이션이 된다. 따라서 투플은 유일성을 가져야 함
모든 투플은 다른 투플과 구별되는 유일한 속성 값이 있어야 함
어떤 특정한 값이 있을 수도 있지만 두개가 합쳐서 유니크한 것은 ok

orderBy로 끄집어 낼 수 있음, 투플의 무순서성 순서는 의미 없다
==
a b c d 나 a c d b 나 상관 없음


속성의 원자성
 : 더 이상 분해할 수 없는 하나의 원자 값만을 갖음
같은 것을 넣고 싶으면 2개 넣고싶을 때 두줄 또는 3개 넣고 싶을 때 세줄로 넣어야 한다.

키: 모든 릴레이션은 키를 갖음
여러개 합쳐서 키를 갖을 수도 있음
키는 단순한 테이블이 아니고 릴레이션임을 보여주는 대표적 개념
현재 데이터만 보는 것이 아니고 미래의 입력 값까지 생각해서 정함
후보키
컬럼 a b c d 
a bc 이런식으로 묶어서 후보키가 될 수 도 있음 - 유일성, 최소성
최소 하나 이상의 후보키를 갖음
폰번호는 후보키가 될 수 있으나 개인정보보호 때문에 선택 될 수 없어서 따로 ID값을 만들어 주는 방법이 제일 편함
 / 슈퍼키 : 유일하게 식별할 수 있는 속성집합 곁다리를 낄수도 있고 안낄수도 있음 / 
기본키 : 중요함 - 투플을 대표하도록 선정된 후보키, 기본적으로 데이터를 하나 가져오거나 삭제할 때 핵심적으로 사용 
대체키 : 하나가 기본키가 되면 나머지는 대체키가 됨
외래키 : 참조되는 기본키 값 중에서 하나를 참조하여 취함 다른 테이블의 기본키를 참조하는 / Ex : 보드 테이블과 유저 테이블이 있을 때 james가 글을 썼다면 첫번째, 아홉번째. 15번째 글 작성자가 같다면 N : 1 의 관계가 됨 보드테이블과 유저테이블의 관계를 자연스럽게 표현해줌(notice)
자세한 속성설명 == 사진 참조


무결성 제약 조건(데이터 무결성을 유지하는 2가지 구현 방식)
1. 개별 응용 프로그램 안에 코드를 추가하여 구현 구현 부담스럽고 비효율적, 향후 유지하기 어려움
2. DB에 무결성 제약 조건 설정 :  할 수 없는 경우 - 보드 테이블 유저테이블이 있을 때 1.번 글 제임스 5번 19번 모두 제임스가 저장햇을 때 제임스를 모두 지우고 싶을 때 유저테이블에서 사라지면 데이터 베이스에서 외래키에서 참조하고 있기 때문에 이 칼럼은 지울 수 없다고 에러남 보드테이블을 먼저 지우고 유저테이블을 지워야하는 제약조건이 발생함

*기본키 제약조건-개체 무결성, 참조 무결성 제약 조건
유저테이블에 있는 내용이거나(릴레이션의 기본키 속성 값과 일치하는 값) null값은 인정됨
아우터조인outerJoin(실전에서는 잘 일어나지 않음-foreign key 설정이 되어있어있기 때문) 무결성이 깨진 상황임 : 히트송아이디에서 송테이블에 있는 sid값 데이터베이스보면 song테이블에 두개정도 없는 정보가 나옴 - foreign키 설정을 안해서 그렇게 보임

외래키 설정시 null 가능

추가 제약 조건 
- 도메인 무결성 제약 조건
체크 값 범위 정함
- 유일성 제약 조건
유니크 속성 : 유일한 값만 들어올 수 있음

제약조건 관계도 시각화(사진 참조)


--정리--
유저스와 관련해서 배운
향후 게시판 작성 시 필요한 내용을 배움
암호화를 처음 해봄
DB에 들어와 있는 Password는 인크립션해서 암호화해서
데이터를 보관하고 있어야 함

없애려면 초기화하는 방법밖에 없음
거꾸로 유추해서 패스워드를 알 수 없음

사용하기 위한
비크립트는 계속 사용하게 될 메소드임

관련해서 로그인 처리도 해봄
로그인 관련 내용은
기억을 하고 있어야 나중에 로그인에 쓸 수 있음
나중에 할 것은 시큐리티 로그인(스프링부트)
그때 방법은 달라지지만 오늘 배운 것대로 할 수가 있음

회원가입도 해봄
나머지는 기존것과 비슷

페이지와 몇개의 데이터를 보게 할 것인가
페이지 단위로 볼 수 있게 해봤음

인터페이스를 하나 만듬
인터페이스를 만들어서 
내가 만든 어플리케이션은 인터페이스 코드만 쓰면됨
그 것을 다오와 함께해서 필요한 비지니스 로직과 함께 작성해봄

다오는 순수하게 데이터를 가지고 오는 것만 함
마이 바티스를 쓰게되면 순수하게 데이터를 가져오는 일만하지
그 이외의 일은 할 수가 없음
그 사이에 구현객체가 약간의 비지니스 로직을 사용함. 앞으로 스프링에서도 하게 됨

오후에는 이론을 다뤗는데 그 중에서 기억할것
기본키와 외래키임
프라이머리 키 / 포린 키

들어가는 순서가 정확해야하는 것을 앞으로 배울 예정

내일은 새롭게 하지 않고 
게시판 DB 관련된 것을 할 것